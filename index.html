<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lil Boy: Bleeding Up — v0.4.25 (spring rare, spike rare enemies) v0.4.34 (stable FX + camera kick)</title>
<style>
  :root{ --bg:#1e1119; --bgTop:#2a1822; --red:#c61b37; --red2:#f13a53; --text:#f1ecf2; }
  *{ box-sizing:border-box }
  html,body{ margin:0; height:100%; background:#000; color:#fff; font-family:system-ui,-apple-system,Inter,Roboto,Arial; overscroll-behavior:none; }
  .stage{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:var(--bg); }
  #wrap{ position:relative; width:100vw; height:100vh; max-width:min(100vw, calc(100vh * 9/16)); max-height:min(100vh, calc(100vw * 16/9)); }
  @media (min-aspect-ratio: 16/9){ #wrap{ width:calc(100vh * 9/16); height:100vh; } }
  @media (max-aspect-ratio: 9/16){ #wrap{ width:100vw; height:calc(100vw * 16/9); } }

  #c{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:manipulation; z-index:1; pointer-events:auto; }

  .hud{ position:absolute; left:12px; top:12px; display:flex; gap:12px; align-items:center; background:rgba(255,255,255,.08); padding:8px 10px; border-radius:10px; backdrop-filter:blur(4px); font-weight:600; font-size:14px; z-index:3; pointer-events:none; }
  .barwrap{ position:absolute; left:12px; right:12px; bottom:12px; padding-bottom:env(safe-area-inset-bottom); z-index:3; pointer-events:none; }
  .bar{
  --edge:#0b0d11;
  --steel1:#1c2026;
  --steel2:#2b313a;
  --steel3:#3b4450;
  --steel4:#5c6775;
  --highlight:#c7d3e3;
  height:20px;
  border-radius:16px;
  position:relative;
  overflow:hidden;
  background:
    /* soft vignette */
    radial-gradient(140% 160% at 50% -30%, rgba(255,255,255,.06), transparent 46%),
    /* steel vertical */
    linear-gradient(180deg, var(--highlight) 0%, var(--steel4) 18%, var(--steel3) 55%, var(--steel1) 100%);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.45),
    0 2px 6px rgba(0,0,0,.5),
    0 0 0 1px rgba(0,0,0,.35);
}
/* inner bevel + subtle cut edges */
.bar::after{
  content:""; position:absolute; inset:2px; border-radius:14px;
  box-shadow:
    inset 0 2px 6px rgba(0,0,0,.45),
    inset 0 -2px 6px rgba(0,0,0,.4),
    inset 0 0 0 1px rgba(255,255,255,.05);
  pointer-events:none;
}
/* moving steel sheen */
.bar::before{
  content:""; position:absolute; top:-30%; bottom:-30%; width:22%;
  background:linear-gradient(120deg, transparent 0%, rgba(255,255,255,.25) 50%, transparent 100%);
  transform: translateX(-140%);
  animation: bezelSheen 3.6s linear infinite;
  border-radius:16px; pointer-events:none; mix-blend-mode:screen;
}
@keyframes bezelSheen{
  0%{ transform: translateX(-140%); }
  100%{ transform: translateX(440%); }
}
  .bar .fill{
  position:absolute; inset:3px 3px 3px 3px; width:auto;
  transform-origin:left center;
  border-radius:12px;
  background:
    radial-gradient(165% 150% at 20% -20%, rgba(255,255,255,.45), rgba(255,255,255,0) 40%),
    linear-gradient(180deg, #ff9c92 0%, #ff3d36 30%, #c3171d 68%, #6e0d14 100%);
  box-shadow:
    inset 0 2px 6px rgba(255,255,255,.25),
    inset 0 -3px 6px rgba(0,0,0,.45),
    0 0 10px rgba(241,58,83,.35);
  filter:saturate(1.50);
}
.bar .fill::after{
  content:""; position:absolute; left:6px; right:6px; top:4px; height:38%;
  background: linear-gradient(180deg, rgba(255,255,255,.35), rgba(255,255,255,0));
  border-top-left-radius:10px; border-top-right-radius:10px; pointer-events:none;
}
.bar .fill::after{ /* glossy top highlight */
  content:""; position:absolute; left:0; right:0; top:0; height:50%;
  background:linear-gradient(180deg, rgba(255,255,255,.35), rgba(255,255,255,0));
  border-top-left-radius:14px; border-top-right-radius:14px;
  pointer-events:none;
}
.bar .fill::before{ /* animated sheen */
  content:""; position:absolute; top:-20%; bottom:-20%; width:25%;
  background:linear-gradient(120deg, transparent 0%, rgba(255,255,255,.28) 50%, transparent 100%);
  transform: translateX(-120%);
  animation: barSheen 2.6s linear infinite;
  mix-blend-mode: screen; pointer-events:none;
}
@keyframes barSheen{
  0%{ transform: translateX(-120%); }
  100%{ transform: translateX(420%); }
}

  .overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,rgba(22,13,20,.25),rgba(22,13,20,.65)); color:#fff; text-align:center; padding:24px; z-index:5; pointer-events:auto; cursor:pointer; }
  .card{ background:rgba(30,17,25,.75); border:1px solid rgba(255,255,255,.14); border-radius:16px; padding:18px; max-width:520px; width:min(92%,520px); box-shadow:0 10px 40px rgba(0,0,0,.45); cursor:auto; }
  .card h1{ margin:0 0 8px; font-size:22px; }
  .muted{ opacity:.9; font-size:14px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:12px; }
  button{ appearance:none; border:none; cursor:pointer; font-weight:700; padding:10px 14px; border-radius:12px; background:var(--red2); color:#fff; }
  button.secondary{ background:#2b1b25; border:1px solid rgba(255,255,255,.18); }

  body.over #c { pointer-events: none !important; }
  body.over #gameover { display:flex !important; }

<style id="nosheen-override">
.bar::before,
.bar .fill::before{ content:none !important; animation:none !important; display:none !important; }
</style>

<style id="steel-dark-center-override">
.bar{
  background:
    radial-gradient(140% 160% at 50% -30%, rgba(255,255,255,.04), transparent 46%),
    linear-gradient(180deg,
      #6b7787 0%,
      #4b5563 12%,
      #2f3641 28%,
      #1b2028 50%,   /* darkest center */
      #2f3641 72%,
      #4b5563 88%,
      #6b7787 100%) !important;
}
</style>
</style>

<style id="bar_capsule_widthsync">
/* Geometry of inner groove */
:root{ --pad:3px; --rad:12px; }
.bar{ position:relative !important; overflow:visible; }
.bar::after{ z-index:5 !important; pointer-events:none !important; } /* steel rim on top */

/* Clip that matches inner steel groove exactly */
.bar > .bar-inner-clip{
  position:absolute;
  left:var(--pad); right:var(--pad);
  top:var(--pad); bottom:var(--pad);
  border-radius:var(--rad);
  overflow:hidden;
  z-index:2;
}

/* Red core now grows by width to keep perfectly round end */
.bar > .bar-inner-clip > .fill{
  position:absolute; left:0; top:0; bottom:0;
  width:0%;                       /* driven by JS mirror of scaleX */
  transform:none !important;      /* stop visual scaling (we mirror it) */
  border-radius:var(--rad) !important;
  z-index:2;
  background-clip:padding-box !important;
  -webkit-background-clip:padding-box !important;
}

/* ensure no stray sheen */
.bar::before, .bar .fill::before{ content:none !important; animation:none !important; display:none !important; }
</style>


<style id="bar_fx_css">
/* --- FX: pulses & dynamic color (non-destructive) --- */
@keyframes barPulseCollect {
  0%   { transform: scaleY(1);    filter: brightness(1); }
  40%  { transform: scaleY(1.50); filter: brightness(1.3); }
  100% { transform: scaleY(1);    filter: brightness(1); }
}
@keyframes barPulseDamage {
  0%   { transform: translateX(0) scaleY(1); filter: brightness(1); }
  20%  { transform: translateX(-2px) scaleY(0.96); filter: brightness(0.85); }
  40%  { transform: translateX(2px)  scaleY(0.96); filter: brightness(0.85); }
  60%  { transform: translateX(-1px) scaleY(0.98); }
  80%  { transform: translateX(1px)  scaleY(0.99); }
  100% { transform: translateX(0)    scaleY(1); }
}
@keyframes barLowBreath {
  0%   { transform: scaleY(1);    filter: saturate(1) brightness(1); }
  50%  { transform: scaleY(1.50); filter: saturate(1.2) brightness(1.2); }
  100% { transform: scaleY(1);    filter: saturate(1) brightness(1); }
}

/* Apply the animations via classes on the red core */
.bar .bar-inner-clip { perspective: 1000px; } /* isolation */
.bar .bar-inner-clip > .fill.collect { animation: barPulseCollect 220ms ease-out; }
.bar .bar-inner-clip > .fill.damage  { animation: barPulseDamage 280ms ease-in-out; }
.bar .bar-inner-clip > .fill.low-breath { animation: barLowBreath 900ms ease-in-out infinite; }

/* Smooth color transitions */
.bar .bar-inner-clip > .fill {
  transition: background 140ms linear;
}
</style>


<style id="bar_fx_css_v2">
/* --- FX v2: brighter colors, clearer pulses, longer low warning --- */
@keyframes barPulseCollectV2 {
  0%   { transform: scaleY(1);    filter: brightness(1) saturate(1); }
  45%  { transform: scaleY(1.50); filter: brightness(1.50) saturate(1.50); }
  100% { transform: scaleY(1);    filter: brightness(1) saturate(1); }
}
@keyframes barPulseDamageV2 {
  0%   { transform: translateX(0) scaleY(1);    filter: brightness(1); }
  20%  { transform: translateX(-2px) scaleY(0.95); filter: brightness(0.85); }
  40%  { transform: translateX(2px)  scaleY(0.95); filter: brightness(0.85); }
  60%  { transform: translateX(-1px) scaleY(0.98); }
  80%  { transform: translateX(1px)  scaleY(0.99); }
  100% { transform: translateX(0)    scaleY(1); }
}
@keyframes barLowBreathV2 {
  0%   { transform: scaleY(1);    filter: saturate(1) brightness(1); }
  50%  { transform: scaleY(1.50); filter: saturate(1.50) brightness(1.50); }
  100% { transform: scaleY(1);    filter: saturate(1) brightness(1); }
}

.bar .bar-inner-clip > .fill.collect { animation: barPulseCollectV2 260ms ease-out; }
.bar .bar-inner-clip > .fill.damage  { animation: barPulseDamageV2 400ms ease-in-out; }
.bar .bar-inner-clip > .fill.low-breath { animation: barLowBreathV2 1400ms ease-in-out infinite; }
.bar .bar-inner-clip > .fill {
  transition: background 120ms linear;
}
</style>


<style id="isaac-hud-v3">
/* Isaac-like HUD (compact) */
.hud{
  position:absolute; left:12px; top:12px;
  display:flex; gap:8px; align-items:center;
  padding:6px 8px;
  border-radius:12px;
  background: linear-gradient(180deg, rgba(12,9,12,.70), rgba(12,9,12,.58));
  border:1px solid rgba(255,255,255,.08);
  box-shadow:
    0 8px 20px rgba(0,0,0,.45),
    inset 0 1px 0 rgba(255,255,255,.08),
    inset 0 -1px 0 rgba(0,0,0,.45);
  color:#ece7df;
  font-weight:900;
  font-size:clamp(12px, 1.6vh, 18px);
  line-height:1;
  letter-spacing:.3px;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  pointer-events:none;
}
.hud > div{ display:flex; align-items:baseline; gap:6px; }
.hud, .hud span, .hud .label{
  text-shadow:
    -1px 0 0 #000,
     1px 0 0 #000,
     0 -1px 0 #000,
     0  1px 0 #000,
     0  2px 0 rgba(0,0,0,.85);
  color:#fff;
}

/* Remove any HUD pulse if present */
#hud.pulse{ animation:none !important; }
</style>

<style id="bar-pulses">
@keyframes barPulseCollect {
  0%   { transform: scaleY(1);    filter: brightness(1) saturate(1); }
  45%  { transform: scaleY(1.50); filter: brightness(1.50) saturate(1.50); }
  100% { transform: scaleY(1);    filter: brightness(1) saturate(1); }
}
@keyframes barPulseDamage {
  0%   { transform: translateX(0) scaleY(1);    filter: brightness(1); }
  20%  { transform: translateX(-2px) scaleY(0.95); filter: brightness(0.85); }
  40%  { transform: translateX(2px)  scaleY(0.95); filter: brightness(0.85); }
  60%  { transform: translateX(-1px) scaleY(0.98); }
  80%  { transform: translateX(1px)  scaleY(0.99); }
  100% { transform: translateX(0)    scaleY(1); }
}
.bar .fill.bar-pulse-collect { animation: barPulseCollect 260ms ease-out; }
.bar .fill.bar-pulse-damage  { animation: barPulseDamage 360ms ease-in-out; }
</style>


<style id="bar-thirds-colors">
.bar .fill{ transition: background 120ms linear; }
</style>


<style id="bar-inner-rim-and-edgeglow">
/* Inner red rim + edge glow for the blood core */
.bar .fill{
  position: relative;
  border-radius: inherit;
  overflow: hidden; /* keep glow inside the steel frame */
}
/* inner rim / bevel */
.bar .fill::before{
  content:"";
  position:absolute;
  inset:2px;
  border-radius: inherit;
  pointer-events:none;
  box-shadow:
    inset 0 0 0 2px rgba(255, 80, 80, .28),
    inset 0 0 14px rgba(255, 60, 60, .22),
    inset 0 -6px 10px rgba(0,0,0,.35),
    inset 0  6px 10px rgba(255,255,255,.06);
}
/* side edge glow (both sides), subtle glassy feel */
.bar .fill::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius: inherit;
  pointer-events:none;
  background:
    linear-gradient(90deg,
      rgba(255,95,95,.40) 0%,
      rgba(255,95,95,.14) 2px,
      rgba(255,95,95,0) 18px,
      rgba(255,95,95,0) calc(100% - 18px),
      rgba(255,95,95,.14) calc(100% - 2px),
      rgba(255,95,95,.42) 100%);
  mix-blend-mode: screen;
  opacity:.95;
}
</style>


<style id="bar-inner-rim-and-edgeglow-v2">
/* Stronger Isaac-like inner rim & glow */
.bar .fill{
  position: relative;
  border-radius: inherit;
  overflow: hidden;
}

/* brighter red rim and inner glass */
.bar .fill::before{
  content:"";
  position:absolute;
  inset:1px; /* tighter to feel like a rim */
  border-radius: inherit;
  pointer-events:none;
  box-shadow:
    inset 0 0 0 2px rgba(255, 95, 95, .55),    /* bright red rim */
    inset 0 0 22px rgba(255, 70, 70, .35),     /* inner red glow */
    inset 0 -10px 18px rgba(0,0,0,.45),        /* bottom darkening */
    inset 0  10px 18px rgba(255,255,255,.10);  /* top soft light */
}

/* side edge glow + sharp vertical split for upper bright / lower dark */
.bar .fill::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius: inherit;
  pointer-events:none;
  background:
    /* vertical highlight (upper half bright, lower dark with sharp knee) */
    linear-gradient(180deg,
      rgba(255,230,230,.55) 0%,
      rgba(255,135,135,.22) 36%,
      rgba(255,135,135,.18) 47%,
      rgba(0,0,0,.38) 50%,
      rgba(0,0,0,.45) 100%),
    /* left inner edge neon */
    linear-gradient(90deg,
      rgba(255,110,110,.65) 0px,
      rgba(255,110,110,.25) 2px,
      rgba(255,110,110,0) 18px),
    /* right inner edge neon */
    linear-gradient(270deg,
      rgba(255,110,110,.65) 0px,
      rgba(255,110,110,.25) 2px,
      rgba(255,110,110,0) 18px);
  mix-blend-mode: screen;
  opacity: .95;
}

/* ensure transitions don't feel sticky */
.bar .fill{ transition: background 120ms linear, filter 120ms linear, transform 120ms linear; }
</style>


<style id="hud-scale-115">
.hud {
  padding: 7px 9px !important; /* ~+15% */
  border-radius: 14px !important;
  gap: 9px !important;
  font-size: clamp(13.8px, 1.50vh, 20.7px) !important;
}
</style>


<style id="hud-scale-120-metal">
/* +5% size from 115% and thicker metallic bezel */
.hud{
  padding: 8px 10px !important;
  border-radius: 15px !important;
  gap: 10px !important;
  font-size: clamp(14.5px, 1.50vh, 21.8px) !important;

  /* thicker bezel with steel look */
  border: 2px solid rgba(220,228,236,0.18) !important;
  background:
    radial-gradient(120% 180% at 20% 0%, rgba(255,255,255,.06), transparent 45%),
    radial-gradient(120% 180% at 80% 120%, rgba(0,0,0,.35), transparent 55%),
    linear-gradient(180deg, rgba(16,18,22,.82), rgba(14,14,18,.70)) !important;

  /* metallic edge & inner bevel */
  box-shadow:
    0 10px 26px rgba(0,0,0,.40),
    0 0 0 1px rgba(22,26,32,.85),
    inset 0 1px 0 rgba(255,255,255,.10),
    inset 0 -2px 0 rgba(0,0,0,.55),
    inset 0 0 0 9999px rgba(0,0,0,0) !important;
}

/* subtle steel grain on labels/numbers still readable */
.hud span, .hud .label, .hud div{
  text-shadow:
    -1px 0 0 #000,
     1px 0 0 #000,
     0 -1px 0 #000,
     0  1px 0 #000,
     0  2px 0 rgba(0,0,0,.9),
     0  0 18px rgba(255,80,80,.12) !important;
}
</style>


<style id="local-fonts-woff2-or-ttf">
/* Load local fonts (keeps HTML tiny; works fully offline if files are next to HTML) */
@font-face {
  font-family: 'Russo One';
  src: url('./assets/fonts/RussoOne-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Exo 2';
  src: url('./assets/fonts/Exo2.ttf') format('truetype');
  font-weight: 800;
  font-style: normal;
  font-display: swap;
}

/* Apply only to HUD so nothing else in the game is affected */
.hud{
  font-family: 'Russo One', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
}
#h, #drops, #best{
  font-family: 'Exo 2', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 800;
}
</style>


<style id="hud-red-glass">
.hud{
  background:
    radial-gradient(140% 120% at 10% 0%, rgba(255,120,120,0.12), transparent 42%),
    radial-gradient(140% 120% at 90% 120%, rgba(0,0,0,0.35), transparent 55%),
    linear-gradient(180deg, rgba(90,20,28,0.70), rgba(28,10,12,0.62));
  border: 2px solid rgba(220, 80, 88, 0.22);
  box-shadow:
    0 10px 26px rgba(0,0,0,.42),
    0 0 0 1px rgba(40,10,12,.85),
    inset 0 1px 0 rgba(255,230,230,.12),
    inset 0 -2px 0 rgba(0,0,0,.55),
    inset 0 0 0 1px rgba(210, 40, 44, .20);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
.hud, .hud *{
  color:#f4f4f4;
  text-shadow:
    -1px 0 0 #000,
     1px 0 0 #000,
     0 -1px 0 #000,
     0  1px 0 #000,
     0  2px 0 rgba(0,0,0,.85);
}
</style>


<style id="hud-number-glow-apply">
/* Subtle red glow for HUD numbers only (keep colors unchanged) */
#hud #h, #hud #drops, #hud #best {
  text-shadow:
    0 0 5px rgba(255, 60, 60, 0.40),
    0 0 10px rgba(255, 60, 60, 0.22) !important;
}
</style>


/* start-overlay image handled with ::before now (cleaned old rule) */
/* Keep the card readable over the art */
#menu .card{
  background: rgba(18, 10, 16, .78);
  border-color: rgba(255,255,255,.16);
  box-shadow: 0 14px 60px rgba(0,0,0,.55);
}

<style id='start-overlay-image'>
/* --- Start screen: full overlay image under the card (not resizing the menu) --- */
#menu{
  /* keep default dark gradient */
  background: linear-gradient(180deg, rgba(22,13,20,.25), rgba(22,13,20,.65)) !important;
  position: absolute;
  inset: 0;
}
#menu::before{
}
#menu::after{content:"";position:absolute;inset:0;background:rgba(0,0,0,.42);z-index:0;pointer-events:none;}
#menu::before{
  content: "";
  position: absolute;
  inset: 0;
  background: url('./assets/images/backgrounds/start.png') center/cover no-repeat;
  filter: brightness(0.50);
  opacity: 0.98;
  z-index: 0;
  pointer-events: none;
}
#menu > *{
  position: relative;
  z-index: 1;
}
/* Keep the card readable */
#menu .card{
  background: rgba(18,10,16,.78) !important;
  border-color: rgba(255,255,255,.16) !important;
  box-shadow: 0 14px 60px rgba(0,0,0,.55) !important;
}
</style>
<style id="poster-glass-css">
/* === Poster Glass start window (Variant A) === */
#menu .poster-glass{
  background: rgba(18,10,16,0.80);
  border: 1px solid rgba(255,255,255,0.16);
  border-radius: 30px;
  padding: 30px;
  width: min(92%, 560px);
  box-shadow:
    0 14px 60px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 -1px 0 rgba(0,0,0,.45);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#menu .menu-title{
  margin: 0 0 22px;
  text-transform: uppercase;
  font-family: 'Russo One', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 900;
  font-size: clamp(28px, 5.2vw, 48px);
  letter-spacing: 0.06em;
  line-height: 1.50;
  color: #f3eef4;
  text-shadow: 0 2px 0 rgba(0,0,0,.6), 0 16px 40px rgba(0,0,0,.6);
}
#menu .onebtn{ margin-top: 4px; }
#menu .onebtn button{
  padding: 14px 28px;
  border-radius: 16px;
  font-weight: 800;
  letter-spacing: 0.02em;
  font-size: 18px;
  background: var(--red2);
  transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}
#menu .onebtn button:hover{ transform: translateY(-2px); filter: brightness(1.50); }
#menu .onebtn button:active{ transform: translateY(0); filter: brightness(0.96); }
</style>
<style id='start-window-polish-v2'>
/* --- Start window polish (centered title with stroke, chrome-red button) --- */
#menu{ align-items:center; justify-content:center; }

#menu .poster-glass{
  background: rgba(18,10,16,0.80);
  border: 1px solid rgba(255,255,255,0.16);
  border-radius: 28px;
  padding: 24px 28px;
  width: min(92%, 540px);
  box-shadow:
    0 14px 60px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.06),
    inset 0 -1px 0 rgba(0,0,0,.45);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

#menu .menu-title{
  margin: 0 0 18px;
  text-transform: uppercase;
  font-family: 'Russo One', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 900;
  font-size: clamp(24px, 4.4vw, 40px); /* меньше и плотнее */
  letter-spacing: 0.06em;
  line-height: 1.50;
  color: #f3eef4;
  text-align:center;
  /* чёрная обводка + мягкая тень */
  -webkit-text-stroke: 1.5px rgba(0,0,0,.85);
  text-shadow:
    0 2px 0 rgba(0,0,0,.85),
    0 12px 28px rgba(0,0,0,.65);
}

#menu .onebtn{ margin-top: 10px; display:flex; justify-content:center; }

/* Chrome red button */
#menu .onebtn #startBtn{
  position: relative;
  padding: 14px 30px;
  border-radius: 18px;
  font-weight: 900;
  letter-spacing: .02em;
  font-size: 18px;
  color: #fff;
  background:
    radial-gradient(120% 180% at 50% 0%, rgba(255,255,255,.25), transparent 36%),
    linear-gradient(180deg, #ff6a6a 0%, #ff3a3a 28%, #c3171d 66%, #6e0d14 100%);
  border: 1px solid rgba(255,255,255,.20);
  box-shadow:
    0 10px 28px rgba(0,0,0,.45),
    inset 0 1px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.45);
  transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
}
#menu .onebtn #startBtn::after{ /* тонкий «блик» сверху */
  content:"";
  position:absolute; left:12px; right:12px; top:8px; height:34%;
  background: linear-gradient(180deg, rgba(255,255,255,.65), rgba(255,255,255,0));
  border-top-left-radius: 14px; border-top-right-radius: 14px;
  pointer-events:none;
  mix-blend-mode:screen;
}
#menu .onebtn #startBtn:hover{
  transform: translateY(-2px);
  filter: brightness(1.50);
  box-shadow:
    0 12px 32px rgba(0,0,0,.5),
    inset 0 1px 0 rgba(255,255,255,.42),
    inset 0 -2px 0 rgba(0,0,0,.5);
}
#menu .onebtn #startBtn:active{
  transform: translateY(0);
  filter: brightness(0.96);
}
</style>
<style id='start-image-title-css'>
/* --- Start screen: image title + CTA (no card) --- */
#menu{ align-items:center; justify-content:center; }
#menu .start-stack{
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 14px;
}
#menu .start-title{
  width: min(60vw, 364px);  /* ~30% меньше от предыдущего min(86vw,520px) */
  height: auto;
  display: block;
  margin: 0 auto;
}
#menu .start-cta{
  position: relative;
  padding: 14px 30px;
  border-radius: 18px;
  font-family: 'Russo One', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 900;
  letter-spacing: .01em;
  font-size: 18px;
  color: #fff;
  border: none;                /* убираем белёсые рамки */
  background-clip: padding-box;
  background:
    linear-gradient(180deg, #ff7272 0%, #ff4545 22%, #d01f23 60%, #7a1116 100%);
  box-shadow:
    0 10px 26px rgba(0,0,0,.40),         /* внешняя тень */
    inset 0 1px 0 rgba(255,255,255,.35), /* верхний блик */
    inset 0 -2px 0 rgba(0,0,0,.35);      /* нижняя тень */
  transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
  overflow: hidden;
}
#menu .start-cta:hover{
  transform: translateY(-2px);
  filter: brightness(1.50);
  box-shadow:
    0 12px 32px rgba(0,0,0,.5),
    inset 0 1px 0 rgba(255,255,255,.5),
    inset 0 -2px 0 rgba(0,0,0,.5);
}
#menu .start-cta:active{ transform: translateY(0); filter: brightness(0.96); }
#menu .start-cta:hover{
  transform: translateY(-2px);
  filter: brightness(1.50);
  box-shadow:
    0 12px 32px rgba(0,0,0,.5),
    inset 0 1px 0 rgba(255,255,255,.42),
    inset 0 -2px 0 rgba(0,0,0,.5);
}
#menu .start-cta:active{ transform: translateY(0); filter: brightness(0.96); }
</style>

<style id="gameover_steel_red">
/* Game Over panel: steel bezel + red glass body */
#gameover { cursor: default; }
#gameover .card-go{
box-shadow: 0 16px 50px rgba(0,0,0,.50);

background: rgba(12,12,14,0.30);
border: 2px solid rgba(126,26,31,0.9);


  position: relative;
  border-radius: 22px;
  padding: 18px 18px 20px;
  width: min(92%, 560px);

  /* ONLY steel frame; center remains glass */
  
  

  
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#gameover .card-go h1{
  margin: 0 0 8px;
  font-size: clamp(22px, 2.8vw, 28px);
  font-weight: 900;
  text-shadow: 0 2px 0 rgba(0,0,0,.65);
}
#gameover .row-go{ margin-top: 14px; }
#gameover .muted{ opacity: .95; font-size: 15px; }

/* Chrome red CTA */
#gameover .cta-chrome{
  position: relative;
  padding: 12px 22px;
  border-radius: 16px;
  font-family: 'Russo One', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 900;
  letter-spacing: .01em;
  font-size: 16px;
  color: #fff;
  border: none;
  background-clip: padding-box;
  background:
    linear-gradient(180deg, #ff7a7a 0%, #ff4a4a 24%, #c61f24 62%, #741116 100%);
  box-shadow:
    0 10px 26px rgba(0,0,0,.42),
    inset 0 1px 0 rgba(255,255,255,.35),
    inset 0 -2px 0 rgba(0,0,0,.45);
  transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
}
#gameover .cta-chrome:hover{
  transform: translateY(-2px);
  filter: brightness(1.50);
  box-shadow:
    0 12px 32px rgba(0,0,0,.5),
    inset 0 1px 0 rgba(255,255,255,.45),
    inset 0 -2px 0 rgba(0,0,0,.5);
}
#gameover .cta-chrome:active{ transform: translateY(0); filter: brightness(0.96); }

/* Remove default card visuals if leaking from base CSS */
#gameover .card:not(.card-go){ border-color: transparent; background: transparent; box-shadow: none; }
</style>


<style id="gameover_steel_frame_upgrade">
#gameover .card-go {
  background: rgba(12,12,14,0.30); /* сохраняем стекло */
  border: 2px solid rgba(160,180,200,0.28);
  border-radius: 22px;
  box-shadow:
    0 0 0 1px rgba(0,0,0,.65),
    0 10px 28px rgba(0,0,0,.55),
    inset 0 1px 0 rgba(255,255,255,.12),
    inset 0 -2px 0 rgba(0,0,0,.65);
  background-clip: padding-box;
  position: relative;
}
#gameover .card-go::before {
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  background:
    linear-gradient(180deg, rgba(220,230,240,.25), rgba(80,90,100,.45) 45%, rgba(20,25,30,.65) 100%);
  mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  padding:2px;
  pointer-events:none;
}
</style>


<style id="gameover_steel_frame_fix">
/* Clean steel border without overlay artifacts. 
   Uses two backgrounds with different background-clip layers: 
   - padding-box keeps the glass center
   - border-box draws the metallic ring
*/
#gameover .card-go{
  /* keep glass center exactly as before */
  border: 2px solid transparent; /* required for border-box layer */
  border-radius: 22px;
  background:
    linear-gradient(rgba(12,12,14,0.30), rgba(12,12,14,0.30)) padding-box,
    linear-gradient(180deg,
      rgba(210,222,236,0.70) 0%,
      rgba(150,162,178,0.60) 14%,
      rgba(92,103,117,0.70) 40%,
      rgba(55,63,74,0.85) 70%,
      rgba(22,26,32,0.95) 100%) border-box;
  box-shadow:
    0 16px 50px rgba(0,0,0,.50),
    inset 0 1px 0 rgba(255,255,255,.08),   /* inner top bevel */
    inset 0 -2px 0 rgba(0,0,0,.55);       /* inner bottom bevel */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  position: relative;
}
/* kill previous masked pseudo-border if it exists */
#gameover .card-go::before{ content:none !important; }
</style>


<style id="gameover_steel_frame_final">
#gameover .card-go{
  /* 1) Сохраняем исходную прозрачность стекла без изменений */
  background: rgba(12,12,14,0.30) !important;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);

  /* 2) Металлическая рамка только через border + тени */
  border-radius: 22px;
  border: 2px solid rgba(182,192,206,0.28);

  /* Внешняя и внутренняя фаски для эффекта стали */
  box-shadow:
    0 16px 50px rgba(0,0,0,.50),      /* существующая внешняя тень */
    0 0 0 1px rgba(22,26,32,.85),     /* тёмная кромка снаружи */
    inset 0 1px 0 rgba(255,255,255,.12),  /* верхний внутренний блик */
    inset 0 -2px 0 rgba(0,0,0,.60),       /* нижняя внутренняя тень */
    inset 0 0 14px rgba(200,210,224,.06); /* мягкий «стальной» отблеск */
}

/* 3) На всякий случай глушим любые псевдо-элементы старых версий */
#gameover .card-go::before,
#gameover .card-go::after{ content:none !important; }
</style>


<style id="gameover_steel_frame_chrome_strong">
/* Stronger chrome-steel bezel; glass stays exactly rgba(12,12,14,.30) */
#gameover .card-go{
  /* keep glass center */
  background:
    linear-gradient(rgba(12,12,14,0.30), rgba(12,12,14,0.30)) padding-box,
    /* steel body (border ring) */
    linear-gradient(180deg,
      rgba(235,242,255,0.95) 0%,
      rgba(194,206,222,0.88) 10%,
      rgba(128,140,156,0.88) 28%,
      rgba(70,80,92,0.92) 52%,
      rgba(38,44,54,0.96) 74%,
      rgba(18,22,28,0.98) 100%) border-box,
    /* subtle steel grain */
    repeating-linear-gradient( 90deg,
      rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px,
      rgba(0,0,0,0.03) 1px, rgba(0,0,0,0.03) 2px) border-box;
  border: 3px solid transparent;           /* thicker ring for stronger read */
  border-radius: 22px;
  background-clip: padding-box, border-box, border-box;
  position: relative;

  /* crisp outer/inner faceting */
  box-shadow:
    0 18px 60px rgba(0,0,0,.55),           /* drop */
    0 0 0 1px rgba(10,12,16,.85),          /* dark outer hairline */
    inset 0 1px 0 rgba(255,255,255,.16),   /* top inner bevel */
    inset 0 -2px 0 rgba(0,0,0,.62),        /* bottom inner shade */
    inset 0 0 22px rgba(200,210,224,.10);  /* soft steel glow */
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

/* add a tight chrome edge highlight just at the border */
#gameover .card-go::after{
  content:"";
  position:absolute; inset:0;
  border-radius:inherit;
  pointer-events:none;
  /* draw only on the border by clipping */
  background:
    radial-gradient(120% 140% at 50% -20%,
      rgba(255,255,255,.35), rgba(255,255,255,0) 55%) border-box,
    linear-gradient(180deg,
      rgba(255,255,255,.25), rgba(255,255,255,0) 45%, rgba(0,0,0,.45) 100%) border-box;
  background-clip: border-box;
  /* inset via outline trick: create inner padding to keep highlight off glass */
  -webkit-mask: 
    linear-gradient(#000 0 0) content-box, 
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
          mask: 
    linear-gradient(#000 0 0) content-box, 
    linear-gradient(#000 0 0);
          mask-composite: exclude;
  padding: 2.5px; /* matches half of border-ish to keep highlight thin */
}

/* kill any earlier pseudo that could overlay */
#gameover .card-go::before{ content:none !important; }
</style>


<style id="gameover_steel_frame_chrome_bright">
#gameover .card-go{
  background:
    linear-gradient(rgba(12,12,14,0.30), rgba(12,12,14,0.30)) padding-box,
    linear-gradient(180deg,
      rgba(255,255,255,0.9) 0%,
      rgba(230,240,255,0.75) 10%,
      rgba(190,202,220,0.72) 40%,
      rgba(140,150,166,0.80) 70%,
      rgba(100,110,120,0.90) 100%) border-box;
  border: 3px solid transparent;
  border-radius: 22px;
  background-clip: padding-box, border-box;
  box-shadow:
    0 16px 50px rgba(0,0,0,.50),
    0 0 0 1px rgba(12,14,16,.75),
    inset 0 1px 0 rgba(255,255,255,.20),
    inset 0 -2px 0 rgba(0,0,0,.55),
    inset 0 0 14px rgba(220,230,255,.18);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  position: relative;
}

/* bright rim light accent */
#gameover .card-go::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
  background: linear-gradient(145deg,
      rgba(255,255,255,.4) 0%,
      rgba(255,255,255,0) 35%,
      rgba(255,255,255,0) 65%,
      rgba(255,255,255,.25) 100%);
  mix-blend-mode: screen;
}

/* disable older versions */
#gameover .card-go::before { content: none !important; }
</style>


<style id="touch-guard-style">
  #c { touch-action: none; -webkit-touch-callout: none; }
</style>

</head>
<body>
<div class="stage">
  <div id="wrap">
    <canvas id="c"></canvas>

    <div class="hud" id="hud" style="display:none">
      <div>Очки: <span id="h">0</span></div>
      <div>Капли: <span id="drops">0</span></div>
      <div>Рекорд: <span id="best">0</span></div>
    </div>

    <div class="barwrap" style="display:none">
      <div class="bar"><div class="fill" id="bloodFill" style="transform:scaleX(1)"></div></div>
    </div>

    <div class="overlay" id="menu">
  <div class="start-stack">
    <img src="./assets/images/text/text_start.png" alt="ВОСХОЖДЕНИЕ ЛИЛ БОЯ" class="start-title"/>
    <button id="startBtn" class="start-cta">Играть</button>
  </div>
</div>
<div class="overlay" id="gameover" style="display:none" tabindex="-1">
  <div class="card card-go">
    <h1 id="goTitle">Ты истёк</h1>
    <div class="muted" id="finalStats">Очки: 0 • Капли: 0</div>
    <div class="row row-go">
      <button id="againBtn" class="cta-chrome">Попробовать ещё</button>
    </div>
  </div>
</div>
</div>
</div>
  </div>
</div>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script type="module">
  const wrap = document.getElementById('wrap');
  const cvs  = document.getElementById('c');
  const ctx  = cvs.getContext('2d');

  // === Texture loader ===
  function makeImg(src){ const im=new Image(); im.src=src; return im; }
  const imgFragile = makeImg("./assets/images/platforms/platform_fragile.png");
  const imgMoving  = makeImg("./assets/images/platforms/platform_moving.png");
  const imgSpring  = makeImg("./assets/images/platforms/platform_spring.png");
  const imgSpike   = makeImg("./assets/images/platforms/platform_spike.png");
  const imgBack = makeImg("./assets/images/backgrounds/back.png");
  
  // Solid platform fixed-width sprites (1..8)
  const imgSolid1 = makeImg("./assets/images/platforms/platform_solid1.png");
  const imgSolid2 = makeImg("./assets/images/platforms/platform_solid2.png");
  const imgSolid3 = makeImg("./assets/images/platforms/platform_solid3.png");
  const imgSolid4 = makeImg("./assets/images/platforms/platform_solid4.png");
  const imgSolid5 = makeImg("./assets/images/platforms/platform_solid5.png");
  const imgSolid6 = makeImg("./assets/images/platforms/platform_solid6.png");
  const imgSolid7 = makeImg("./assets/images/platforms/platform_solid7.png");
  const imgSolid8 = makeImg("./assets/images/platforms/platform_solid8.png");
  const SOLID_SPRITES = [imgSolid1,imgSolid2,imgSolid3,imgSolid4,imgSolid5,imgSolid6,imgSolid7,imgSolid8];
function imgReady(im){ return !!(im && im.complete && (im.naturalWidth||im.width)>0); }
  
  function drawInfiniteBg(ctx, camY, W, H){
    if (!imgReady(imgBack)) return;
    const dpr = (window.devicePixelRatio||1);
    const px = v => Math.round(v*dpr)/dpr;
    const iw = (imgBack.naturalWidth||imgBack.width)||1;
    const ih = (imgBack.naturalHeight||imgBack.height)||1;
    const scale = W / iw;           // fit to width
    const tileH = ih * scale;
    let off = (camY * 0.5 * scale) % tileH; // parallax 0.5
    if (off < 0) off += tileH;
    const y1 = px(-off);
    const y2 = px(y1 + tileH);
    ctx.drawImage(imgBack, 0,0, iw,ih, 0, y1, W, tileH);
    ctx.drawImage(imgBack, 0,0, iw,ih, 0, y2, W, tileH);
  }

  // === tiny falling pixel sparks ===
  const SPARK_LAYERS = [
    { count: 40, size: 1, speed: 18,  alpha: 0.35 }, // far
    { count: 28, size: 2, speed: 30,  alpha: 0.45 }, // mid
    { count: 16, size: 3, speed: 48,  alpha: 0.55 }  // near
  ];
  const SPARKS = [];
  function initSparks(W, H){
    SPARKS.length = 0;
    const rng = Math.random;
    for (let li=0; li<SPARK_LAYERS.length; li++){
      const L = SPARK_LAYERS[li];
      const arr = [];
      for (let i=0;i<L.count;i++){
        arr.push({
          x: Math.random()*W,
          y: Math.random()*H,
          jx: (rng()*0.6-0.3),       // slight horizontal jitter
        });
      }
      SPARKS.push(arr);
    }
  }
  function drawSparks(ctx, camY, W, H, t){
    if (!SPARKS.length) initSparks(W, H);
    const dpr = (window.devicePixelRatio||1);
    const px = v => Math.round(v*dpr)/dpr;
    for (let li=0; li<SPARK_LAYERS.length; li++){
      const L = SPARK_LAYERS[li];
      const arr = SPARKS[li];
      ctx.globalAlpha = L.alpha;
      for (let i=0; i<arr.length; i++){
        const s = arr[i];
        // falling based on time only (independent from camera), loop via modulo H
        let yy = (s.y + L.speed * t) % (H + 20);
        if (yy < -20) yy += (H + 20);
        // mild side drift gives flicker feel
        const xx = s.x + Math.sin((t*0.6 + i*0.7 + li)*2.0) * (2 + L.size) + s.jx * 8;
        const sz = L.size;
        // draw pixel-rect without smoothing
        ctx.fillStyle = "rgba(255,70,70,1)";
        ctx.fillRect(px(xx), px(yy), px(sz), px(sz));
      }
    }
    ctx.globalAlpha = 1;
  }
function solidCapsReady(){ return false; }
  // Visual heights and width-from-aspect helper for non-solid
  // Robust mobile detection (doesn't rely on IS_MOBILE declared later)
  const __DPR0 = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  const __MOBILE_GUESS0 = (window.matchMedia && matchMedia('(pointer:coarse)').matches)
    || (Math.min(window.innerWidth, window.innerHeight) <= 820 && __DPR0 >= 2)
    || /Mobi|Android|iPhone|iPad|iPod|Mobile|CriOS/i.test(navigator.userAgent);
  const MOBILE_GEOM_SCALE = __MOBILE_GUESS0 ? 1.50 : 1.0;
  const VHEIGHT = { solid:38, fragile:32, moving:36, spring:36, spike:46 };
  const VHEIGHT_SCALED = {
    solid: Math.round(VHEIGHT.solid  * MOBILE_GEOM_SCALE),
    fragile: Math.round(VHEIGHT.fragile* MOBILE_GEOM_SCALE),
    moving:  Math.round(VHEIGHT.moving * MOBILE_GEOM_SCALE),
    spring:  Math.round(VHEIGHT.spring * MOBILE_GEOM_SCALE),
    spike:   Math.round(VHEIGHT.spike  * MOBILE_GEOM_SCALE)
  };
  function widthFromAR(img, targetH){
    const h0 = (img.naturalHeight||img.height)||1;
    const w0 = (img.naturalWidth||img.width)||1;
    const s = targetH / h0;
    return Math.max(8, Math.round(w0 * s));
  }
ctx.imageSmoothingEnabled = false;
  const DPR  = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  var IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod|Mobile|CriOS/i.test(navigator.userAgent)
                    || (window.matchMedia && matchMedia('(pointer:coarse)').matches);
  var MOBILE_SCALE = IS_MOBILE ? 1.0 : 1.0;
  let W=0, H=0;
  function fit(){ const r=wrap.getBoundingClientRect(); W=cvs.width=Math.round(r.width*DPR); H=cvs.height=Math.round(r.height*DPR); }
  new ResizeObserver(fit).observe(wrap); fit();

  const tg = window.Telegram?.WebApp||null; if(tg){ try{ tg.ready(); tg.expand(); }catch(e){} }

  const hudH=document.getElementById('h'), hudDrops=document.getElementById('drops'), hudBest=document.getElementById('best');
  const bloodFill=document.getElementById('bloodFill');
  const menuEl=document.getElementById('menu'), overEl=document.getElementById('gameover');
  const startBtn=document.getElementById('startBtn'), howBtn=document.getElementById('howBtn'), againBtn=document.getElementById('againBtn'), shareBtn=document.getElementById('shareBtn');

  const imgPlayer=new Image(); imgPlayer.src='./assets/images/lil boy/lil boy.png';
const imgPlayerRed = new Image(); imgPlayerRed.src = './assets/images/lil boy/lil boy_red.png';

  const imgDrop=new Image();   imgDrop.src='./assets/images/game elements/drop.png';
  let playerImgOk=false, dropImgOk=false; imgPlayer.onload=()=>playerImgOk=true; imgDrop.onload=()=>dropImgOk=true;

  // Physics (slightly quicker horizontal feel)
  const G=3200, JUMP=-1250, VX_MAX=440, SMOOTH=6.8;
  const T_UP=Math.abs(JUMP/G), PEAK=(JUMP*JUMP)/(2*G), REACH_Y=PEAK*0.8, FLIGHT=2*T_UP;
  let MAX_DX = VX_MAX * FLIGHT * 0.8;

  const STATE={MENU:0,PLAY:1,OVER:2}; let state=STATE.MENU;
  const player={x:0,y:0,r:28,vx:0,vy:0, sx:1, sy:1, landBounce:0};
  let blood=1, drainPerSec=0.085, dropRefill=0.18; let lastSpringAt=-999; let springRings=[]; let lastSpikeAt=-999; let spikeRings=[];
  let heightTop=0, score=0, dropsCollected=0;
  const bestKey='lb_bleeding_best'; let best=Number(localStorage.getItem(bestKey)||0); hudBest.textContent=best;

  const platforms=[]; const drops=[];
  let SPACING = 0; let cameraY = 0; let hitTimer=0; let camKick=0;
// FX: drop particles only
  const sparks=[]; const bloodFX=[];

  // RNG
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  const SEED = 1337;
  function randN(seed,n){ return mulberry32((seed ^ (n*0x9e3779b9))>>>0)(); }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }





function drawSolidCaps(ctx, p){
  // Draw solid platform strictly from provided fixed-width sprites (1..8)
  if (typeof SOLID_SPRITES === 'undefined') return false;
  const px = (v)=> (typeof DPR!=='undefined' ? Math.round(v*DPR)/DPR : Math.round(v));

  // Choose once
  if (p.spr == null){
    let bestIdx=-1, bestW=p.w, bestDiff=Infinity;
    for (let i=0;i<SOLID_SPRITES.length;i++){
      const im = SOLID_SPRITES[i];
      if (!imgReady(im)) continue;
      const ih=(im.naturalHeight||im.height)||1, iw=(im.naturalWidth||im.width)||1;
      const sc = p.h/ih, dw = Math.round(iw*sc);
      const d = Math.abs(dw - p.w);
      if (d < bestDiff){ bestDiff=d; bestIdx=i; bestW=dw; }
    }
    if (bestIdx>=0){ p.spr=bestIdx; p.w=bestW; }
  }

  const im = (p.spr!=null) ? SOLID_SPRITES[p.spr] : null;
  if (!im || !imgReady(im)) return false;

  const ih=(im.naturalHeight||im.height)||1, iw=(im.naturalWidth||im.width)||1;
  const sc = p.h/ih;
  const dw = Math.round(iw*sc), dh = Math.round(p.h);
  const cx = p.x + p.w/2, dx = Math.round(cx - dw/2);

  ctx.drawImage(im, 0,0, iw,ih, px(dx), px(p.y), px(dw), px(dh));
  p.x=dx; p.w=dw; p.h=dh;
  return true;
}

let ringIndex=0, ringTopY=0, worldTopY=0, lastMainX=0;

  function addPlatform(cx,y,w,h,type='solid', vx=0){
    const p={x:cx-w/2,y,w,h,type,ttl:Infinity,touched:false,shake:0,vx:vx,alive:true};
    platforms.push(p); return p;
  }
  function addDropOnPlatform(p, offsetX=0, lift=28){
  const r = Math.round(18 * MOBILE_GEOM_SCALE);
  const liftAdj = Math.round(lift * MOBILE_GEOM_SCALE);
  const d = { x: p.x + p.w/2 + offsetX, y: p.y - liftAdj, r, parent: p, offsetX, lift: liftAdj };
  drops.push(d);
  return d;
}
function diffT(n){ return clamp((n-6)/70, 0, 1); }

  function genRing(seed, n, prevTopY, lastX){
    const r = (k)=>randN(seed, n*9973 + k);
    const t = diffT(n);
    const baseStep = Math.min(SPACING, REACH_Y);
    const stepY   = baseStep * ((((typeof __MOBILE_GUESS0!=='undefined' && __MOBILE_GUESS0) || (typeof IS_MOBILE!=='undefined' && IS_MOBILE) || (window.matchMedia && matchMedia('(orientation: portrait)').matches))) ? 1.20 : 1.0);  // spacing +20% на мобильных
    const y       = prevTopY - stepY;

    const dxScale = n < 4 ? 0.40 : lerp(0.75, 1.50, t);
    const side    = (n&1)?1:-1;
    const dx      = (0.35 + r(1)*0.5) * MAX_DX * dxScale * side;
    const cx      = clamp(lastX + dx, 0.02*W, 0.98*W);

    const wMain   = lerp(0.36*W, 0.20*W, clamp(n/50,0,1)) * lerp(1.0, 0.92, t);
    const pFrag   = lerp(0.15, 0.50, t);
    const pMove   = (n>=12) ? lerp(0.05, 0.28, t) : 0.0;
    const rPick   = r(2);
    let type = 'solid', vx=0;
    if (rPick < pFrag){ type='fragile'; }
    else if (rPick < pFrag + pMove){ type='moving'; vx = lerp(60, 120, r(21)) * (side>0?1:-1); }

    const main    = {x:cx - wMain/2, y, w:wMain, h:22, type, vx};
    let topY = y, sidePlat=null, dropSide=null;

    if (r(3) < (n<4 ? 0.40 : 0.58)){
      const w2  = lerp(0.24*W, 0.15*W, clamp(n/50,0,1));
      const cx2 = clamp(cx + (r(4)-0.5)*MAX_DX*0.95, 0.02*W, 0.98*W);
      const cy  = y - lerp(stepY*0.38, stepY*0.58, r(5));
      sidePlat  = {x:cx2 - w2/2, y:cy, w:w2, h:18, type:'solid', vx:0};
      topY      = Math.min(topY, cy);
      if (r(6) < 0.78) dropSide = {x: cx2 + (r(7)-0.5)*w2*0.35, y: cy - 36, r:18};
    }

    
    
    // --- Stable rarity: spring (bonus) and spike (enemy) ---
    if (main.type==='solid' && n>=6){
      const ringsSince = n - lastSpringAt;
      const recentCount = springRings.filter(rr => n - rr < 12).length;
      const ok = (ringsSince >= 4) && (recentCount < 3);
      const pSpring = ok ? 0.12 : 0.0;
      if (Math.random() < pSpring){ main.type='spring'; }
    }
    if (sidePlat && sidePlat.type==='solid' && n>=18){
      const ringsSince = n - lastSpikeAt;
      const recentCount = spikeRings.filter(rr => n - rr < 18).length;
      const ok = (ringsSince >= 8) && (recentCount < 2);
      const pSpike = ok ? 0.18 : 0.0;
      if (Math.random() < pSpike){ sidePlat.type='spike'; }
    }
const dropMain = {x: cx + (r(8)-0.5)*(wMain*0.35), y: y - 36, r:18};
    return {main, side:sidePlat, dropMain, dropSide, topY, mainCx:cx};
  }

  function spawnAheadIfNeeded(){
    while (worldTopY > (cameraY - H*0.8)){
      const ring = genRing(SEED, ringIndex, ringTopY, lastMainX);
      const m = (function(){
      const _t = ring.main.type;
      const _h = VHEIGHT_SCALED[_t] || ring.main.h;
      let _w = ring.main.w;
      if (_t!=='solid'){ const _img = (_t==='fragile')?imgFragile: (_t==='moving')?imgMoving: (_t==='spring')?imgSpring: (_t==='spike')?imgSpike: null; if (_img && imgReady(_img)) _w = (_t==='spring' ? widthFromAR(imgMoving, _h) : widthFromAR(_img, _h));} const __m = addPlatform(ring.main.x + ring.main.w/2, ring.main.y, _w, _h, _t, ring.main.vx||0); return __m;
    })();
      if (m.type==='spring'){ lastSpringAt = ringIndex; springRings.push(ringIndex); }
      addDropOnPlatform(m, ring.dropMain.x - (ring.main.x + ring.main.w/2), 28);
      if (ring.side){
        const s = (function(){
      const _t = ring.side.type;
      const _h = VHEIGHT_SCALED[_t] || ring.side.h;
      let _w = ring.side.w;
      if (_t!=='solid'){ const _img = (_t==='fragile')?imgFragile: (_t==='moving')?imgMoving: (_t==='spring')?imgSpring: (_t==='spike')?imgSpike: null; if (_img && imgReady(_img)) _w = (_t==='spring' ? widthFromAR(imgMoving, _h) : widthFromAR(_img, _h));} const __s = addPlatform(ring.side.x + ring.side.w/2, ring.side.y, _w, _h, _t, 0); return __s;
    })();
        if (s.type==='spike'){ lastSpikeAt = ringIndex; spikeRings.push(ringIndex); }
        if (false){
          const rx = s.x + s.w/2 + ((Math.random()<0.5?-1:1) * (W*0.18));
          const ry = s.y - stepY*0.75;
          addPlatform(rx, ry, Math.max(54, s.w*0.9), s.h, 'spring', 0);
        }
        if (ring.dropSide){ addDropOnPlatform(s, ring.dropSide.x - (ring.side.x + ring.side.w/2), 28); }
      }
      lastMainX = ring.mainCx;
      ringTopY  = ring.topY;
      worldTopY = Math.min(worldTopY, ringTopY);
      ringIndex++;
    }
  }

  // Input
  const input={dir:0};
  window.input = input; // expose to touch controls
  window.addEventListener('keydown',e=>{
    if(e.key==='ArrowLeft'||e.key==='a') input.dir=-1;
    if(e.key==='ArrowRight'||e.key==='d') input.dir=1;
    if(state===STATE.MENU && e.key==='Enter') startGame();
    if(state===STATE.OVER && (e.key==='Enter'||e.key===' ')) restart();
  });
  window.addEventListener('keyup',e=>{ if(['ArrowLeft','a','ArrowRight','d'].includes(e.key)) input.dir=0; });
  let touchX=null;

  function overlayRestart(e){ if(state!==STATE.OVER) return; e?.stopPropagation?.(); e?.preventDefault?.(); restart(); }
  overEl.addEventListener('click', overlayRestart);
  overEl.addEventListener('touchstart', overlayRestart, {passive:false});
  againBtn.addEventListener('click', overlayRestart);

  startBtn.onclick=startGame;
  if (howBtn) howBtn.onclick=()=>alert('Свайпы/стрелки влево-вправо. Автопрыжок. Сквозные края без шлейфа. Капли парят выше.');
  if (shareBtn) shareBtn.onclick=()=>{
    const msg=`Мой счёт в Lil Boy: Bleeding Up — ${score} • Капли: ${dropsCollected}`;
    navigator.clipboard?.writeText(msg);
    alert('Текст скопирован.');
  };

  // Wrap helpers
  function wrapX(x){
    const limit = W;
    if (x < -player.r) return x + limit + player.r*2;
    if (x > limit + player.r) return x - (limit + player.r*2);
    return x;
  }
  function withinXWrap(px, p){
    const a = (x)=> (x >= p.x && x <= p.x+p.w);
    return a(px) || a(px - W) || a(px + W);
  }
  function dxTorus(px, qx){
    let dx = px - qx;
    if (dx >  W/2) dx -= W;
    if (dx < -W/2) dx += W;
    return dx;
  }

  function addDropSparks(x,y){
    for(let i=0;i<14;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 120 + Math.random()*120;
      sparks.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp - 50,
        r: 4 + Math.random()*3,
        alpha: 0.8,
        life: 360,
      });
    }
  }

  

function spawnBloodSplash(x,y){
  for(let i=0;i<12;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 180 + Math.random()*180;
    const r  = 3 + Math.random()*4;
    bloodFX.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-60,r,alpha:1,life:320});
  }
}
function seedWorld(){
    platforms.length=0; drops.length=0; sparks.length=0;
    ringIndex=0; lastSpringAt=-999; springRings=[]; lastSpikeAt=-999; spikeRings=[];
    const start = addPlatform(W*0.5, H*0.82, 0.42*W, 42, 'solid');
    addDropOnPlatform(start, 0, 36);
    lastMainX = start.x + start.w/2;
    ringTopY  = start.y;
    worldTopY = ringTopY;
    for(let i=0;i<10;i++){
      const ring = genRing(SEED, ringIndex, ringTopY, lastMainX);
      const m = (function(){
      const _t = ring.main.type;
      const _h = VHEIGHT_SCALED[_t] || ring.main.h;
      let _w = ring.main.w;
      if (_t!=='solid'){ const _img = (_t==='fragile')?imgFragile: (_t==='moving')?imgMoving: (_t==='spring')?imgSpring: (_t==='spike')?imgSpike: null; if (_img && imgReady(_img)) _w = (_t==='spring' ? widthFromAR(imgMoving, _h) : widthFromAR(_img, _h));}
      const __m = addPlatform(ring.main.x + ring.main.w/2, ring.main.y, _w, _h, _t, ring.main.vx||0); return __m;
    })();
      if (m.type==='spring'){ lastSpringAt = ringIndex; springRings.push(ringIndex); }
      addDropOnPlatform(m, ring.dropMain.x - (ring.main.x + ring.main.w/2), 28);
      if (ring.side){
        const s = (function(){
      const _t = ring.side.type;
      const _h = VHEIGHT_SCALED[_t] || ring.side.h;
      let _w = ring.side.w;
      if (_t!=='solid'){ const _img = (_t==='fragile')?imgFragile: (_t==='moving')?imgMoving: (_t==='spring')?imgSpring: (_t==='spike')?imgSpike: null; if (_img && imgReady(_img)) _w = (_t==='spring' ? widthFromAR(imgMoving, _h) : widthFromAR(_img, _h));}
      const __s = addPlatform(ring.side.x + ring.side.w/2, ring.side.y, _w, _h, _t, 0); return __s;
    })();
        if (s.type==='spike'){ lastSpikeAt = ringIndex; spikeRings.push(ringIndex); }
        if (false){
          const rx = s.x + s.w/2 + ((Math.random()<0.5?-1:1) * (W*0.18));
          const ry = s.y - stepY*0.75;
          addPlatform(rx, ry, Math.max(54, s.w*0.9), s.h, 'spring', 0);
        }
        if (ring.dropSide){ addDropOnPlatform(s, ring.dropSide.x - (ring.side.x + ring.side.w/2), 28); }
      }
      lastMainX = ring.mainCx; ringTopY = ring.topY; worldTopY = Math.min(worldTopY, ring.topY); ringIndex++;
    }
  }

  function startGame(){
    // show HUD + progress bar instantly on start
    try {
      document.getElementById('hud').style.display = 'flex';
      const bw = document.querySelector('.barwrap');
      if (bw) bw.style.display = 'block';
    } catch(e) {}

    fit();
    document.body.classList.remove('over');
    state=STATE.PLAY; menuEl.style.display='none'; overEl.style.display='none';
    input.dir = 0;
    SPACING = (IS_MOBILE ? 0.40*H : 0.19*H);  // мобильный spacing увеличен, но без перебора
    MAX_DX  = VX_MAX * (2*Math.abs(JUMP/G)) * 0.8;
    blood=1; score=0; dropsCollected=0; heightTop=0; cameraY=0;
    seedWorld();
    const p0 = platforms[0];
    player.r = 28 * Math.max(1, DPR);
    player.x = p0.x + p0.w/2;
    player.y = p0.y - player.r - 40;
    player.vx=0; player.vy=0; player.sx=1; player.sy=1; player.landBounce=0;
    lastTime=performance.now(); loop();
  }

  function gameOver(reason='blood'){
    input.dir=0; touchX=null;
    state=STATE.OVER;
    overEl.style.display=''; document.body.classList.add('over');
    const titleEl = overEl.querySelector('h1');
    if (titleEl) titleEl.textContent = (reason === 'fall') ? 'Ты не взошёл' : 'Ты истёк';
    document.getElementById('finalStats').textContent = `Очки: ${score} • Капли: ${dropsCollected}`;
    if(score>best){ best=score; localStorage.setItem(bestKey,String(best)); hudBest.textContent=best; }
    try{ navigator.vibrate(50); }catch(e){}
    try{ overEl.focus(); }catch(e){}
}
  function restart(){ startGame(); }

  let lastTime=performance.now();
  function loop(now=performance.now()){
    if(state!==STATE.PLAY) return;
    const dtMs = Math.min(32, now-lastTime); lastTime=now;
    const dt = dtMs/1000;
    update(dt, dtMs); render(); requestAnimationFrame(loop);
  }

  function update(dt, dtMs){
    if (camKick>0){ camKick = Math.max(0, camKick - dt*18); }

    if (hitTimer>0){ hitTimer -= dtMs; if (hitTimer<0) hitTimer=0; }

    const targetVx = input.dir * VX_MAX;
    player.vx += (targetVx - player.vx) * (SMOOTH * dt);
    const nextX = player.x + player.vx*dt;
    player.x  = wrapX(nextX);

    const prevY = player.y;
    player.vy += G * dt;
    player.y  += player.vy * dt;

    const cameraTarget = player.y - H*0.62;
    cameraY += (cameraTarget - cameraY) * Math.min(1, 10*dt);
    const bottomY  = cameraY + H;
    const cleanupY = bottomY + 120;

    if (player.y + player.r > bottomY) return gameOver('fall');

    const step = Math.min(SPACING, REACH_Y);
    const currentHeight = Math.max(0, Math.round((H*0.82 - player.y) / step));
    heightTop = Math.max(heightTop, currentHeight);
    score = heightTop; hudH.textContent=score;

    const tDiff = Math.max(0, Math.min(1, heightTop/80));
    const drainBase = 0.085;
    const drainAdd  = lerp(0.0, 0.06, tDiff);
    drainPerSec = Math.max(0, Math.min(0.18, drainBase + drainAdd));
    blood -= drainPerSec * dt; if(blood<0) blood=0;
    bloodFill.style.transform=`scaleX(${Math.max(0,blood)})`;
    if(blood<=0) return gameOver('blood');

    // Platforms
    for (let i=platforms.length-1;i>=0;i--){
      const p=platforms[i];
      if(p.type==='moving'){
        p.x += p.vx * dt;
        const minX = 0.02*W, maxX = 0.98*W - p.w;
        if (p.x < minX){ p.x=minX; p.vx = Math.abs(p.vx); }
        if (p.x > maxX){ p.x=maxX; p.vx = -Math.abs(p.vx); }
      }
      if(p.type==='fragile' && p.touched){
        p.shake = 1;
        p.ttl -= dt*1000;
        if(p.ttl<=0){ p.alive=false; platforms.splice(i,1); continue; }
      }
      if (p.y > cleanupY){ p.alive=false; platforms.splice(i,1); continue; }
    }

    // Drops
    for (let i=drops.length-1;i>=0;i--){
      const d=drops[i];
      if (d.parent && !d.parent.alive){ drops.splice(i,1); continue; }
      if (d.parent){ d.x = d.parent.x + d.parent.w/2 + d.offsetX; d.y = d.parent.y - d.lift; }
      if (d.y > cleanupY){ drops.splice(i,1); }
    }

    // Collision
    const prevFoot = prevY + player.r;
    const foot     = player.y + player.r;
    let landed = false;
    for (let i=0;i<platforms.length;i++){
      const p=platforms[i];
      if (player.vy > 0 && withinXWrap(player.x, p) && prevFoot <= p.y && foot >= p.y){
        player.y = p.y - player.r;
        player.vy = (p.type==='spring' ? JUMP*1.6 : JUMP);
        if (p.type==='spike'){ blood = Math.max(0, blood - 0.07); spawnBloodSplash(player.x, player.y); hitTimer=160; camKick=4; try{ navigator.vibrate(25);}catch(e){} }
        landed = true;
        if (p.type==='fragile' && !p.touched){ p.touched=true; p.ttl=600; }
        try{ navigator.vibrate(10); }catch(e){}
        break;
      }
    }

    // Squash/stretch
    let targetSy = 1, targetSx = 1;
    if (player.vy < -80){ targetSy = 1.22; targetSx = 0.92; }
    else if (player.vy > 80){ targetSy = 0.94; targetSx = 1.18; }
    if (landed){ targetSy = 1.18; targetSx = 0.92; player.landBounce = 1.0; }
    if (player.landBounce > 0){
      const t = player.landBounce;
      const osc = Math.sin((1-t)*Math.PI*1.2) * (t*0.12);
      targetSy = 1 + osc; targetSx = 1 - osc*0.6;
      player.landBounce = Math.max(0, t - dt*2.2);
    }
    const k = 12*dt;
    player.sy += (targetSy - player.sy) * k;
    player.sx += (targetSx - player.sx) * k;

    // Pickups + sparks
    for (let i=0;i<drops.length;i++){
      const d=drops[i];
      const dx = dxTorus(player.x, d.x);
      const dy = player.y - d.y;
      if (Math.hypot(dx,dy) < (player.r + d.r)*0.9){
        drops.splice(i,1); i--;
        blood=Math.min(1, blood+dropRefill);
        dropsCollected++; hudDrops.textContent=dropsCollected;
        addDropSparks(d.x, d.y);
        try{ navigator.vibrate(8); }catch(e){}
      }
    }

    // FX update
    for (let i=sparks.length-1;i>=0;i--){
      const s=sparks[i];
      s.life -= dtMs; s.alpha -= dt*2.2;
      s.vy += 900*dt;
      s.x += s.vx*dt; s.y += s.vy*dt;
      if (s.life<=0 || s.alpha<=0){ sparks.splice(i,1); }
    }
    // Blood FX update
    for (let b=bloodFX.length-1;b>=0;b--){
      const f=bloodFX[b];
      f.life -= dtMs; f.alpha -= dt*2.0;
      f.vy += 1100*dt; f.x += f.vx*dt; f.y += f.vy*dt;
      if (f.life<=0 || f.alpha<=0){ bloodFX.splice(b,1); }
    }

    spawnAheadIfNeeded();
  }

  function render(){
    drawInfiniteBg(ctx, cameraY, W, H);
    drawSparks(ctx, cameraY, W, H, (performance.now()/1000));

    ctx.save(); ctx.translate(0,-cameraY + (camKick||0));

    const now = performance.now();
    platforms.forEach(p=>{
      let fill = '#2d1a25', stroke='rgba(241,58,83,.55)', lw=2;
      const __t = (p.type==='fragile')?imgFragile:(p.type==='moving')?imgMoving:(p.type==='spring')?imgSpring:(p.type==='spike')?imgSpike:null;
      const __has = !!(__t && imgReady(__t));
      if(__has){ fill='rgba(0,0,0,0)'; stroke='rgba(0,0,0,0)'; } if (p.type==='spring'){ fill='#3a1723'; stroke='rgba(255,95,120,1)'; lw=3; } if (p.type==='spike' && !(__t && imgReady(__t))){ fill='#2b121b'; stroke='rgba(241,58,83,0.95)'; lw=3; }
      if (p.type==='fragile' && !p.touched){ stroke='rgba(255,120,120,.95)'; lw=2.6; fill='#3b212c'; }
      else if (p.type==='fragile' && p.touched){ stroke='rgba(255,160,160,.95)'; lw=2.6; fill='#3b212c'; }
      else if (p.type==='moving'){ fill = '#2a1a26'; stroke='rgba(241,58,180,.6)'; }
      // re-apply transparency when texture exists
      if(__has){ fill='rgba(0,0,0,0)'; stroke='rgba(0,0,0,0)'; lw=0; }

      const shakeX = p.shake ? Math.sin(now*0.06)*2 : 0;
      ctx.save(); ctx.translate(shakeX,0);
      if (p.type==='spring'){
        lw=0; stroke='rgba(0,0,0,0)';
        const tNow = performance.now();
        const pulse = 1 + 0.04 * Math.sin(tNow * 0.010 + (p.x * 0.02)); // ±4%
        ctx.translate(p.x + p.w/2, p.y + p.h/2);
        ctx.scale(pulse, pulse);
        ctx.translate(-(p.x + p.w/2), -(p.y + p.h/2));
        const intensity = (pulse - 1) / 0.04;
        ctx.shadowColor = 'rgba(255,95,130,' + (0.25 + 0.35 * Math.max(0,intensity)) + ')';
        ctx.shadowBlur = 10 + 14 * Math.max(0,intensity);
      }
      if (p.type!=='spring' && p.type!=='solid') { const r=7; ctx.beginPath();
      ctx.moveTo(p.x+r,p.y);
      ctx.arcTo(p.x+p.w,p.y,p.x+p.w,p.y+p.h,r);
      ctx.arcTo(p.x+p.w,p.y+p.h,p.x,p.y+p.h,r);
      ctx.arcTo(p.x,p.y+p.h,p.x,p.y,r);
      ctx.arcTo(p.x,p.y,p.x+p.w,p.y,r);
      ctx.closePath();
      ctx.fillStyle=fill; ctx.fill();
      if (p.type==='spring'){
        const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
        grad.addColorStop(0, 'rgba(255,120,140,0.35)');
        grad.addColorStop(1, 'rgba(255,120,140,0.0)');
        ctx.fillStyle = grad; ctx.fillRect(p.x, p.y, p.w, p.h);
      }
      if (p.type==='spike' && !(__t && imgReady(__t))){
        const teeth=Math.max(3, Math.floor(p.w/16)); const tw=p.w/teeth, th=8;
        for(let i=0;i<teeth;i++){ const tx=p.x+i*tw, ty=p.y-th; ctx.beginPath(); ctx.moveTo(tx,ty+th); ctx.lineTo(tx+tw*0.5,ty); ctx.lineTo(tx+tw,ty+th); ctx.closePath(); ctx.fillStyle='rgba(241,58,83,0.95)'; ctx.fill(); }
      }
      ctx.strokeStyle=stroke; ctx.lineWidth=lw; ctx.stroke();
      } if (p.type==='solid') { drawSolidCaps(ctx, p); } else { const t = (p.type==='fragile')?imgFragile:(p.type==='moving')?imgMoving:(p.type==='spring')?imgSpring:(p.type==='spike')?imgSpike:null; if (t && imgReady(t)) { if(p.type==='spring'){ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;} ctx.drawImage(t, Math.round(p.x), Math.round(p.y), Math.round(p.w), Math.round(p.h)); } }
      ctx.restore();
    });

    // Drop particles
    sparks.forEach(s=>{
      ctx.globalAlpha=Math.max(0, Math.min(1, s.alpha));
      const grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.r*2);
      grd.addColorStop(0, 'rgba(241,58,83,0.9)');
      grd.addColorStop(1, 'rgba(241,58,83,0.0)');
      ctx.fillStyle=grd;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r*2.2, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    });

    // Drops
    drops.forEach(d=>{
      const s=d.r*2.2;
      if(dropImgOk){ ctx.drawImage(imgDrop, d.x-s/2, d.y-s/2, s, s); }
      else{ ctx.beginPath(); ctx.fillStyle='#f13a53'; ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill(); }
    });

    // Blood splash blobs
    bloodFX.forEach(f=>{
      ctx.globalAlpha=Math.max(0, Math.min(1, f.alpha));
      const grd = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.r*2.2);
      grd.addColorStop(0, 'rgba(210,20,40,0.95)');
      grd.addColorStop(1, 'rgba(210,20,40,0.0)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(f.x, f.y, f.r*2.2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    });

    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.scale(player.sx, player.sy);
    if(playerImgOk){ const s=player.r*2.6; ctx.drawImage((hitTimer>0 && imgPlayerRed && imgPlayerRed.complete ? imgPlayerRed : imgPlayer), -s/2, -s/2, s, s); }
    else{ ctx.beginPath(); ctx.fillStyle='#0d0b0d'; ctx.arc(0,0,player.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();

    ctx.restore();

    hudH.textContent=score; hudBest.textContent=best;
  }

  menuEl.style.display='';
</script>

<script id="bar_capsule_widthsync_js">
(function(){
  function clamp(v){ return v<0?0:v>1?1:v; }
  function readScale(el){
    var tr = el.style.transform || '';
    var m = tr.match(/scaleX\(([^)]+)\)/);
    if(m){
      var p = parseFloat(m[1]);
      if(!isNaN(p)) return clamp(p);
    }
    return null;
  }
  function setup(){
    var bar  = document.querySelector('.bar');
    if(!bar) return;
    var fill = document.getElementById('bloodFill') || bar.querySelector('.fill');
    if(!fill) return;

    // Ensure wrapper exists and fill is inside it
    var wrap = bar.querySelector('.bar-inner-clip');
    if(!wrap){
      wrap = document.createElement('div');
      wrap.className = 'bar-inner-clip';
      bar.appendChild(wrap);
    }
    if(fill.parentNode !== wrap) wrap.appendChild(fill);

    // Mirror current scaleX to width% (so there's no initial gap)
    var p0 = readScale(fill);
    if(p0===null){
      // fallback: measure current visual width/proportion inside wrapper
      var fr = fill.getBoundingClientRect(), wr = wrap.getBoundingClientRect();
      p0 = wr.width>0 ? clamp(fr.width / wr.width) : 0;
    }
    fill.style.width = (p0*100).toFixed(3) + '%';

    // Every frame: mirror scaleX to width
    function raf(){
      var p = readScale(fill);
      if(p!==null){
        fill.style.width = (p*100).toFixed(3) + '%';
      }
      requestAnimationFrame(raf);
    }
    requestAnimationFrame(raf);
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setup);
  else setup();
})();
</script>


<script id="bar_fx_js">
(function(){
  var wrap, fill;
  var lowThreshold = 0.15; // 15% left => low pulse
  var lowActive = false;
  var collectCooldown = 0;
  function clamp(v){ return v<0?0:v>1?1:v; }

  function ensureEls(){
    if (!wrap || !fill){
      var bar = document.querySelector('.bar');
      if(!bar) return false;
      wrap = bar.querySelector('.bar-inner-clip');
      fill = wrap && (document.getElementById('bloodFill') || wrap.querySelector('.fill'));
    }
    return !!(wrap && fill);
  }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function toHex(n){ n = Math.max(0, Math.min(255, Math.round(n))); return ('0'+n.toString(16)).slice(-2); }

  // Map percent -> color: bright red at 100%, darker/blood at 0%
  function colorFor(p){
    // high: #ff3a2e ; mid: #d22b2b ; low: #6b1a1a
    var hi = {r:255,g:58 ,b:46};
    var md = {r:210,g:43 ,b:43};
    var lo = {r:107,g:26 ,b:26};
    var c1, c2, t;
    if (p > 0.5){ c1 = md; c2 = hi; t = (p-0.5)/0.5; }
    else       { c1 = lo; c2 = md; t = p/0.5; }
    var r = lerp(c1.r,c2.r,t), g = lerp(c1.g,c2.g,t), b = lerp(c1.b,c2.b,t);
    return '#' + toHex(r) + toHex(g) + toHex(b);
  }

  function updateVisual(p){
    if(!ensureEls()) return;
    var col = colorFor(p);
    // Keep the existing glossy gradient logic but override base colors
    fill.style.background = 'linear-gradient(180deg,'+col+' 0%,'+col+' 55%, '+col+' 100%)';
    // Low pulse
    if(p < lowThreshold){
      if(!lowActive){
        lowActive = true;
        fill.classList.add('low-breath');
      }
    } else if(lowActive){
      lowActive = false;
      fill.classList.remove('low-breath');
    }
  }

  // Public hooks for game code
  function pulseOnce(cls, cooldownMs){
    if(!ensureEls()) return;
    if (cls==='collect'){
      // prevent spam pulses if many drops at once
      var now = performance.now();
      if (now - collectCooldown < 120) return;
      collectCooldown = now;
    }
    fill.classList.remove(cls);
    // force reflow to restart animation
    void fill.offsetWidth;
    fill.classList.add(cls);
  }

  window.barOnCollect = function(){ pulseOnce('collect'); };
  window.barOnDamage  = function(){ pulseOnce('damage');  };

  // Observe progress: mirror width% already used in this file
  function readP(){
    if(!ensureEls()) return 0;
    var w = fill.style.width;
    if(w && w.endsWith('%')){
      var v = parseFloat(w);
      if(!isNaN(v)) return clamp(v/100);
    }
    // fallback
    var fr = fill.getBoundingClientRect(), wr = wrap.getBoundingClientRect();
    return wr.width>0 ? clamp(fr.width/wr.width) : 0;
  }

  function raf(){
    updateVisual(readP());
    requestAnimationFrame(raf);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ ensureEls(); raf(); });
  else { ensureEls(); raf(); }
})();
</script>


<script id="bar_fx_js_v2">
(function(){
  var wrap, fill;
  var lowThreshold = 0.12; // 12% -> low warning starts earlier and longer
  var lowActive = false;
  var collectCooldown = 0;
  var prevP = null;

  function clamp(v){ return v<0?0:v>1?1:v; }
  function ensureEls(){
    if (!wrap || !fill){
      var bar = document.querySelector('.bar');
      if(!bar) return false;
      wrap = bar.querySelector('.bar-inner-clip');
      fill = wrap && (document.getElementById('bloodFill') || wrap.querySelector('.fill'));
    }
    return !!(wrap && fill);
  }

  // --- Color utils ---
  function hexToRgb(hex){
    hex = hex.replace('#','');
    if(hex.length===3){
      return { r:parseInt(hex[0]+hex[0],16), g:parseInt(hex[1]+hex[1],16), b:parseInt(hex[2]+hex[2],16) };
    }
    return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) };
  }
  function rgbToHex(r,g,b){
    r=Math.max(0,Math.min(255,Math.round(r)));
    g=Math.max(0,Math.min(255,Math.round(g)));
    b=Math.max(0,Math.min(255,Math.round(b)));
    function h(n){ return ('0'+n.toString(16)).slice(-2); }
    return '#'+h(r)+h(g)+h(b);
  }
  function mix(a,b,t){
    return { r:a.r+(b.r-a.r)*t, g:a.g+(b.g-a.g)*t, b:a.b+(b.b-a.b)*t };
  }
  function shade(rgb, amt){ // amt in [-1..1], >0 lighten, <0 darken
    var w = amt>=0 ? 255 : 0, t = Math.abs(amt);
    return { r: rgb.r + (w-rgb.r)*t, g: rgb.g + (w-rgb.g)*t, b: rgb.b + (w-rgb.b)*t };
  }

  // brighter palette (right->left sample you showed)
  var HI = hexToRgb('#FF3A2E'); // bright
  var MD = hexToRgb('#B22A20'); // warm deep
  var LO = hexToRgb('#4f000e'); // dark blood

  function baseColor(p){
    var c1, c2, t;
    if (p > 0.5){ c1 = MD; c2 = HI; t = (p-0.5)/0.5; }
    else       { c1 = LO; c2 = MD; t = p/0.5; }
    return mix(c1,c2,t);
  }

  function updateVisual(p){
    if(!ensureEls()) return;
    // gradient with slight top-light and bottom-dark based on base
    var base = baseColor(p);
    var top  = shade(base,  0.10); // lighter 10%
    var mid  = base;
    var bot  = shade(base, -0.18); // darker 18%
    var grad = 'linear-gradient(180deg,'+rgbToHex(top.r,top.g,top.b)+' 0%,'+
                                  rgbToHex(mid.r,mid.g,mid.b)+' 55%,'+
                                  rgbToHex(bot.r,bot.g,bot.b)+' 100%)';
    fill.style.background = grad;

    // Low pulse control
    if(p < lowThreshold){
      if(!lowActive){ lowActive = true; fill.classList.add('low-breath'); }
    } else if(lowActive){
      lowActive = false; fill.classList.remove('low-breath');
    }
  }

  function pulseOnce(cls, cooldownMs){
    if(!ensureEls()) return;
    if (cls==='collect'){
      var now = performance.now();
      if (now - collectCooldown < 120) return;
      collectCooldown = now;
    }
    fill.classList.remove(cls); void fill.offsetWidth; fill.classList.add(cls);
  }

  // Exposed hooks
  window.barOnCollect = function(){ pulseOnce('collect'); };
  window.barOnDamage  = function(){ pulseOnce('damage');  };

  function readP(){
    if(!ensureEls()) return 0;
    var w = fill.style.width;
    if(w && w.endsWith('%')){
      var v = parseFloat(w);
      if(!isNaN(v)) return clamp(v/100);
    }
    // fallback
    var fr = fill.getBoundingClientRect(), wr = wrap.getBoundingClientRect();
    return wr.width>0 ? clamp(fr.width/wr.width) : 0;
  }

  function raf(){
    var p = readP();
    updateVisual(p);

    // Auto-detect pulses if игра не вызывает вручную:
    if (prevP !== null){
      var dp = p - prevP;
      if (dp > 0.02) { pulseOnce('collect'); }   // заметное пополнение
      if (dp < -0.03){ pulseOnce('damage');  }   // ощутимая потеря
    }
    prevP = p;

    requestAnimationFrame(raf);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ ensureEls(); raf(); });
  else { ensureEls(); raf(); }
})();
</script>


<style id="bar_fx_palette_v3">
/* Keep previous animations; only palette + low threshold change here */
</style>
<script id="bar_fx_js_palette_v3">
(function(){
  var wrap, fill;
  var lowThreshold = 0.33; // start warning when ~1/3 left
  var lowActive = false;
  function clamp(v){ return v<0?0:v>1?1:v; }
  function ensureEls(){
    if (!wrap || !fill){
      var bar = document.querySelector('.bar');
      if(!bar) return false;
      wrap = bar.querySelector('.bar-inner-clip');
      fill = wrap && (document.getElementById('bloodFill') || wrap.querySelector('.fill'));
    }
    return !!(wrap && fill);
  }
  // Color utils
  function hexToRgb(hex){
    hex = hex.replace('#','');
    if(hex.length===3){
      return { r:parseInt(hex[0]+hex[0],16), g:parseInt(hex[1]+hex[1],16), b:parseInt(hex[2]+hex[2],16) };
    }
    return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) };
  }
  function rgbToHex(r,g,b){
    r=Math.max(0,Math.min(255,Math.round(r)));
    g=Math.max(0,Math.min(255,Math.round(g)));
    b=Math.max(0,Math.min(255,Math.round(b)));
    function h(n){ return ('0'+n.toString(16)).slice(-2); }
    return '#'+h(r)+h(g)+h(b);
  }
  function mix(a,b,t){ return { r:a.r+(b.r-a.r)*t, g:a.g+(b.g-a.g)*t, b:a.b+(b.b-a.b)*t }; }
  function shade(rgb, amt){
    var w = amt>=0 ? 255 : 0, t = Math.abs(amt);
    return { r: rgb.r + (w-rgb.r)*t, g: rgb.g + (w-rgb.g)*t, b: rgb.b + (w-rgb.b)*t };
  }

  // Your palette (high -> mid -> low)
  var HI = hexToRgb('#ce160d');
  var MD = hexToRgb('#b20b03');
  var LO = hexToRgb('#4f000e');

  function baseColor(p){ // p in [0..1], 1 = full, 0 = empty
    var c1, c2, t;
    if (p > 0.5){ c1 = MD; c2 = HI; t = (p-0.5)/0.5; } // 50..100% -> MD->HI
    else       { c1 = LO; c2 = MD; t = p/0.5; }        // 0..50%   -> LO->MD
    return mix(c1,c2,t);
  }

  function updateVisual(p){
    if(!ensureEls()) return;
    var base = baseColor(p);
    // keep slight glossy depth: top lighter, bottom darker
    var top  = shade(base,  0.10);
    var mid  = base;
    var bot  = shade(base, -0.18);
    var grad = 'linear-gradient(180deg,'+rgbToHex(top.r,top.g,top.b)+' 0%,'+
                                  rgbToHex(mid.r,mid.g,mid.b)+' 55%,'+
                                  rgbToHex(bot.r,bot.g,bot.b)+' 100%)';
    fill.style.background = grad;

    if(p < lowThreshold){
      if(!lowActive){ lowActive = true; fill.classList.add('low-breath'); }
    } else if(lowActive){
      lowActive = false; fill.classList.remove('low-breath');
    }
  }

  function readP(){
    if(!ensureEls()) return 0;
    var w = fill.style.width;
    if(w && w.endsWith('%')){
      var v = parseFloat(w);
      if(!isNaN(v)) return clamp(v/100);
    }
    var fr = fill.getBoundingClientRect(), wr = wrap.getBoundingClientRect();
    return wr.width>0 ? clamp(fr.width/wr.width) : 0;
  }

  function raf(){ updateVisual(readP()); requestAnimationFrame(raf); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ ensureEls(); raf(); });
  else { ensureEls(); raf(); }
})();
</script>


<script id="bar-pulse-hooks">
(function(){
  function ensureFill(){
    var bar = document.querySelector('.bar');
    if(!bar) return null;
    var wrap = bar.querySelector('.bar-inner-clip') || bar;
    var fill = wrap.querySelector('#bloodFill') || wrap.querySelector('.fill');
    return fill || null;
  }
  function pulse(cls){
    var fill = ensureFill();
    if(!fill) return;
    fill.classList.remove(cls);
    void fill.offsetWidth;
    fill.classList.add(cls);
  }
  // Public hooks for game events
  window.barOnCollect = function(){ pulse('bar-pulse-collect'); };
  window.barOnDamage  = function(){ pulse('bar-pulse-damage');  };

  // Auto-detect via drops counter if hooks aren't called
  document.addEventListener('DOMContentLoaded', function(){
    var dropsEl = document.getElementById('drops');
    if(!dropsEl) return;
    var last = parseInt(dropsEl.textContent || '0', 10) || 0;
    var obs = new MutationObserver(function(){
      var val = parseInt(dropsEl.textContent || '0', 10) || 0;
      if (val > last) { window.barOnCollect(); }
      if (val < last) { window.barOnDamage();  }
      last = val;
    });
    obs.observe(dropsEl, { childList:true, characterData:true, subtree:true });
  });
})();
</script>




<script id="bar-thirds-logic-smooth">
(function(){
  var wrap, fill;
  function clamp(v){ return v<0?0:v>1?1:v; }
  function ensureEls(){
    if(!fill){
      var bar = document.querySelector('.bar');
      if(!bar) return false;
      wrap = bar.querySelector('.bar-inner-clip') || bar;
      fill = (wrap.querySelector('#bloodFill') || wrap.querySelector('.fill'));
    }
    return !!fill;
  }
  function hexToRgb(hex){
    hex = hex.replace('#',''); 
    if(hex.length===3){ return {r:parseInt(hex[0]+hex[0],16), g:parseInt(hex[1]+hex[1],16), b:parseInt(hex[2]+hex[2],16)}; }
    return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) };
  }
  function rgbToHex(o){ 
    function h(n){ n=Math.max(0,Math.min(255,Math.round(n))); return ('0'+n.toString(16)).slice(-2); }
    return '#'+h(o.r)+h(o.g)+h(o.b);
  }
  function mix(a,b,t){ return { r:a.r+(b.r-a.r)*t, g:a.g+(b.g-a.g)*t, b:a.b+(b.b-a.b)*t }; }
  function shade(rgb, amt){
    var w = amt>=0 ? 255 : 0, t = Math.abs(amt);
    return { r: rgb.r + (w-rgb.r)*t, g: rgb.g + (w-rgb.g)*t, b: rgb.b + (w-rgb.b)*t };
  }

  // Base colors for thirds
  var C1 = hexToRgb('#c81120'); // high
  var C2 = hexToRgb('#9b0014'); // mid
  var C3 = hexToRgb('#410002'); // low

  // thresholds and blending width
  var t1 = 2/3;   // 0.666...
  var t2 = 1/3;   // 0.333...
  var bw = 0.05;  // 5% blend zones

  function baseColorSmooth(p){
    // p in [0..1], 1 = full
    if (p >= t1 + bw) return C1;                  // pure high
    if (p <= t2 - bw) return C3;                  // pure low
    if (p > t1 - bw && p < t1 + bw){              // blend C1 -> C2
      var t = (t1 + bw - p) / (2*bw);             // 0 at left edge (C1), 1 at right (C2)
      return mix(C1, C2, clamp(t));
    }
    if (p > t2 - bw && p < t2 + bw){              // blend C2 -> C3
      var t = (t2 + bw - p) / (2*bw);             // 0 at left edge (C2), 1 at right (C3)
      return mix(C2, C3, clamp(t));
    }
    // between blends: pure mid
    return C2;
  }

  function readP(){
    if(!ensureEls()) return 0;
    var w = fill.style.width;
    if (w && w.endsWith('%')){
      var v = parseFloat(w);
      if(!isNaN(v)) return clamp(v/100);
    }
    var fr = fill.getBoundingClientRect(), wr = wrap.getBoundingClientRect();
    return wr.width>0 ? clamp(fr.width/wr.width) : 0;
  }

  function tick(){
    if(!ensureEls()) return;
    var p = readP();
    var base = baseColorSmooth(p);
    // vertical gloss: top lighter +10%, bottom darker -18%
    var top = shade(base, 0.10);
    var mid = base;
    var bot = shade(base, -0.18);
    fill.style.background = 'linear-gradient(180deg,'+rgbToHex(top)+' 0%,'+rgbToHex(mid)+' 55%,'+rgbToHex(bot)+' 100%)';
    requestAnimationFrame(tick);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick);
  else tick();
})();
</script>


<script id="touch-move-controls">
(function(){
  var canvas = document.getElementById('c');
  if (!canvas) return;

  // Fallback input object if code expects it.
  if (!window.input) window.input = { dir: 0 };

  function sideFromEvent(e){
    var t = (e.touches && e.touches[0]) || (e.changedTouches && e.changedTouches[0]);
    var cx = (t ? t.clientX : (e.clientX||0));
    var rect = canvas.getBoundingClientRect();
    var x = cx - rect.left;
    return (x < rect.width * 0.5) ? -1 : 1;
  }

  var active = false;

  function onStart(e){
    if (e.cancelable) e.preventDefault();
    try{ if (typeof state !== 'undefined' && typeof STATE !== 'undefined' && state !== STATE.PLAY) return; }catch(_){}
    active = true;
    window.input.dir = sideFromEvent(e);
  }
  function onMove(e){
    if (!active) return;
    if (e.cancelable) e.preventDefault();
    try{ if (typeof state !== 'undefined' && typeof STATE !== 'undefined' && state !== STATE.PLAY) return; }catch(_){}
    window.input.dir = sideFromEvent(e);
  }
  function onEnd(e){
    if (e.cancelable) e.preventDefault();
    active = false;
    window.input.dir = 0;
  }

  canvas.addEventListener('touchstart', onStart, {passive:false});
  canvas.addEventListener('touchmove',  onMove,  {passive:false});
  canvas.addEventListener('touchend',   onEnd,   {passive:false});
  canvas.addEventListener('touchcancel',onEnd,   {passive:false});
})();
</script>

</body>
</html>

<style id="bar-final-overrides">
/* 1) Kill any moving sheens for sure */
.bar::before,
.bar .fill::before{
  content: none !important;
  animation: none !important;
  display: none !important;
}
/* 2) Ensure red core stays above inner shadow and keeps rounded end */
.bar{ position: relative !important; overflow: hidden !important; }
.bar .fill{
  z-index: 2 !important;
  border-radius: 12px !important;
}
.bar::after{ z-index: 1 !important; }
/* (keep dark steel center from previous override; not changing colors here) */
</style>
